#sage --python estimation/get_dose_opt.py -i eisen/model1/eisen_model_smple.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_data.csv  > logs/eisen_log_dose.txt
#sage --python estimation/get_dose_opt_1state.py -i eisen/model1/eisen_model_1state.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_1state.csv  > logs/eisen_log_dose.txt
# sage --python estimation/get_dose_opt_bin_drch.py -i eisen/model1/eisen_model_1state.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_1state_dose.csv  > logs/eisen_log_dose.txt
# sage --python estimation/get_dose_opt_bin_drch.py -i eisen/model1/eisen_model_1state.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_1state_dose.csv -s eisen/model1/eisen_sskm_data_172.csv > logs/eisen_log_dose.txt
# sage --python estimation/get_dose_bin_drch_cap_mp.py -i eisen/model1/eisen_model_1state.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_1state_dose.csv -s eisen/model1/eisen_sskm_hypo.csv > logs/eisen_log_dose.txt &
#nohup sage --python estimation/get_dose_bin_drch_cap_mp.py -i eisen/model1/eisen_model_1state.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_1state_dose.csv -s eisen/model1/eisen_sskm_hypo.csv > logs/eisen_log_dose_233.txt &
#nohup sage --python estimation/get_dose_bin_drch_cap_mp.py -i eisen/model1/eisen_model_1state.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_1state_dose.csv -s eisen/model1/eisen_sskm_hypo_263.csv > logs/eisen_log_dose_263.txt &
#nohup sage --python estimation/get_dose_bin_drch_cap_mp.py -i eisen/model1/eisen_model_1state.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_1state_dose.csv -s eisen/model1/eisen_sskm_hypo_024.csv > logs/eisen_log_dose_074.txt &
# nohup sage --python estimation/get_dose_bin_drch_cap_mp.py -i eisen/model1/eisen_model_1state.drh -o eisen/model1/eisen_model_Out.txt -d eisen/model1/eisen_model_1state_dose.csv -s eisen/model1/eisen_sskm_opt_data_065.csv > logs/eisen_log_dose_074.txt &
from __future__ import print_function
import os
import subprocess
import re
import sys, getopt
import csv

import multiprocessing
# from multiprocessing import Pool#, Queue, Process
from pathos.multiprocessing import ProcessingPool

import collections
from collections import OrderedDict
from decimal import Decimal

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

#from model.property import *

from model.haModel import *
from model.phaModel import *
from model.ha_factory import *
from model.node import *
from parser.parseSTL import *
from parser.parseParameters import *
from parser.parseEquations import *
from parser.parseExpr import *
from parser.parseCondition import *

#from model.interval import *
#from model.box import *
#from model.condition import *
import numpy as np
import random as rnd
from util.reach import *
from util.graph import *
from util.stack import *
from util.heap import *
import ha2smt.smtEncoder as smten
from paramUtil.interval import *
from paramUtil.box import *
import paramUtil.box_factory as bfact
from util.parseOutput import *
from util.smtOutput import *
#from paramUtil.readDataBB import *
from model.node_factory import *
# from ha2smt.smtEncoder import *
import ha2ode.HA2ode as hode

import sage.all as sage
import sagepy.sageCal as sagec
import sagepy.optimizeOffset as opt_off
import sagepy.drugFourier as drug_four

import numpy
import time

PLOT = hode.PLOT
if PLOT:
	import matplotlib
	# matplotlib.use('Agg')
	import matplotlib.pyplot as plt
	from matplotlib.backends.backend_pdf import PdfPages
	from matplotlib.patches import Rectangle

import itertools

import gp_classifier_dReach as gpc

# fig = plt.figure()

tempfolder = os.path.join('temp','testBox_dose')
SAT = 51
UNSAT = 52
UNKNOWN = -1
TRUE = 1
FALSE = 0
UNDET = 2
ONLYMARKED = 1
NOMARK = 0
PATH_LEN = 2 #0
DELTA = 0.15
EPS = 0.2
N_GRIDS = 0.1
MIN_EPS = 0.00101
MIN_DELTA = 0.001
DATA_NOISE = 0.4
noise = {}
# DEBUG = True
DEBUG = False
TEST = False
# TEST = True
POOL = True
REVERSE = True

dReachCmd = "dReach"
dRealCmd = "dReal3"
# Optimizer = collections.namedtuple('Optimizer', ['x', 'fun', 'success'])
Instance = collections.namedtuple('Instance', ['p1', 'p2'])
BoxEvaluate = collections.namedtuple('BoxEvaluate', ['ip', 'op'])
Result = collections.namedtuple('Result', ['p0', 'p1', 'p2'])
one_time = 0
PropRow = 0
rank = 0
# RESUME = True 
RESUME = False
#TEST = False
# TEST = True
GP_Window = 200
GP_thres = 0.2
DATA_tp = 5
GPC = True
index = 1
Rows = 20
count = 20
eg = 200
Nterms = 20 #30
if Rows == 20:
	suf = 'qn_gpc_1_p_'
else:
	suf = 'dose_ed_1_'
def toStr(expr):
	exprString = str(expr).replace('e^', 'exp')#.replace('t', 'tm')
	return exprString

class BoxInfo(object):
	"""docstring for ClassName"""
	def __init__(self, *tuple):
		super(BoxInfo, self).__init__()
		self.pri = tuple[0]
		self.box = tuple[1]
		self.delta = tuple[2]
		self.prop = tuple[3]

	def __lt__(self, nxt):
		return self.pri < nxt.pri

	def __gt__(self, nxt):
		return self.pri > nxt.pri

	def getInfo(self):
		return self.pri, self.box, self.delta, self.prop
		
	def __repr__(self):
		sk = str(self.pri) + ', ' + str(self.box) + ', '+ str(self.delta)+ ', '+ str(self.prop)
		return sk

	def __str__(self):
		return self.__repr__()
		
class Dosage: 
	def __init__(self, a = [], b = 0):
		if len(a) > 0:
			self.result = Result(p0=a[0], p1= a[1], p2 = a[2])
		else:
			self.result = Result(p0=UNSAT, p1= UNSAT, p2 = UNSAT)
		self.value = b	
	def __str__(self):
		return '('+str(self.result) + ' dose:'+ str(self.value)+')'
	def __repr__(self):
		return '('+str(self.result) + ' dose:'+ str(self.value)+')'

def findsubsets(S,m):
	return set(itertools.combinations(S, m))

def plotBox(currentAxis, b, combs, boxType= FALSE):
	#if boxType = TRUE:
	# print(boxType)
	col = 'white'
	if boxType == TRUE:
		col = 'blue'
	elif boxType == UNDET:
		col = 'white'
	elif boxType == FALSE:
		col = 'black'
	# plt.figure()	
	if b.size() == 2:
		b_edges = b.get_map()
		x = []
		w = []
		for it in combs:
			intrvl = b_edges[it]
			x.append(intrvl.leftBound())
			w.append(intrvl.width())
		currentAxis.add_patch(Rectangle((x[0], x[1]), w[0], w[1], facecolor=col, alpha=1))
	# plotBox.show()
	# return plt

def main(argv):
	k_length = PATH_LEN
	d = DELTA	
	#global EPS
	#EPS = 1 * d
	one_time = 0
	plotName = 'plotBox_'+suf+'{0}.pdf'.format(index)
	satName = 'satbox_'+suf+'{0}.csv'.format(index)
	resultName = 'result_'+suf+'{0}.csv'.format(index)
	
	# inputfile = sys.argv[1]
	# paramfile = sys.argv[2]
	# datafile = sys.argv[3]
	paramfile = ''
	paramdefaultfile = ''
	observedfile = ''
	
	try:
		opts, args = getopt.getopt(argv,"hi:p:o:d:f:s:",["ifile=","pfile=", "ofile=", "dfile=","defaultparam=","sskm="])
	except getopt.GetoptError:
			print("Box.py -i <inputfile> -p <paramFile> -o <outputfile> -d <dataFile> -f <defaultparam> -s <observed>")
			sys.exit(2)
			
	for opt, arg in opts:
		if opt == '-h':
			print("Box.py -i <inputfile> -p <paramFile> -o <outputfile> -d <dataFile> -f <defaultparam> -s <observed>")
			sys.exit()
		elif opt in ("-i", "--ifile"):
			inputfile = arg
			print("Input file is :" + inputfile)
		elif opt in ("-p", "--pfile"):
			paramfile = arg
			print("Param file is :" + paramfile)
		elif opt in ("-o", "--ofile"):
			outputfile = arg
			print("Output file is :" + outputfile)
		elif opt in ("-d", "--datafile"):
			datafile = arg
			print("Data file is :" + datafile)
		elif opt in ("-f", "--defaultparam"):
			paramdefaultfile = arg
			print("paramdefault file is :" + paramdefaultfile)
		elif opt in ("-s", "--sskm"):
			observedfile = arg
			print("observedfile file is :" + observedfile)
	
	inFileName = inputfile.split('.')[0]
	outfile = inFileName+'_'+satName

	all_res_file = inFileName+'_'+resultName

	# ha = getModel(inputfile)
	# print('model parsed')
	# print(str(ha))
	default_paramFromFile = {}
	if len(paramdefaultfile) > 0:
		default_paramFromFile = getEquationsFile(paramdefaultfile)
		print('Default Params')
		for var in default_paramFromFile:
			print(var + ' : '+ str(default_paramFromFile[var]))

	all_sat_file = 'sat_box_all_ed_{0}.csv'.format(index) #.format(rank)
	all_q_file = 'queued_box_all_ed_{0}.csv'.format(index) #.format(rank)

	# resume_sat_file = 'sat_box_all_qn_gpc_dose.csv' #.format(rank)
	# resume_q_file = 'queued_box_all_qn_gpc_dose.csv' #.format(rank)
	if not RESUME:
		fp = open(all_sat_file, 'w')
		fp.close()
		fp = open(all_q_file, 'w')
		fp.close()

	print('---- sskm_rows ----')
	sskm_rows = {}
	with open(observedfile, 'r') as file:
		csvreader = csv.reader(file)
		header = next(csvreader)
		print(header, type(header))
		for row in csvreader:
			rf = {}
			rn = int(row[0])			
			hypo_params = []
			for i in range(0, len(row)):
				rf.update({header[i]:float(row[i])})

			#for i in range(0, len(row)-1):
				if header[i] in ['d_1','p_1','p_19','p_37','p_47','p_48','ic_0','ic_1','ic_2','ic_3','ic_4','ic_5','ic_6','ic_7','ic_8','ic_9','ic_10','ic_11','ic_12','ic_13','ic_14','ic_15','ic_16','ic_17','ic_18','ic_19']:
					hypo_params.append((header[i], float(row[i])))
			#for i in range(11, len(row)-1):
				#hypo_params.append((header[i], float(row[i])))
			# Lt4 = float(row[i+1])
			# hypo
			# hypo_cal = float(row[i+2])
			if rn in range(Rows*(index-1), Rows*(index-1)+Rows):
				sskm_rows.update({(rn):(hypo_params, rf)})
				print(rn, rf)

			#break
	sskm_rows_keys = sorted(sskm_rows.keys(), reverse=REVERSE)
	print('--------', sskm_rows_keys)
	def getEstimatedParameters(model, params, d, klen, datafile, fixed, outputEqns):

		all_data = []
		all_props = []
		tp = 0
		with open(datafile) as fp:
			fr = csv.reader(fp, delimiter=',')
			for row in fr:
				tp += 1
				# if tp == PropRow:
				data = [float(row[i]) for i in range(len(row))]
				
				(prop, propn1, propn2, mode) = getPropertyFromData(data, fixed, outputEqns)
				 #convert2Prop(data, dtype) # convert a row to property
				# if DEBUG:
				print(mode, 'Property: ', prop) #, ' State: ', dtype)
				print(mode, 'PropertyNeg: --- ')
				print(propn1)
				print(propn2) #, ' State: ', dtype)
				(pn, pn1, pn2, mode) = getProperties((prop, propn1, propn2), mode) #, dtype)
				all_data.append(data)
				all_props.append((pn, pn1, pn2, mode))

				if tp >= DATA_tp:
					break

		sbox = getBox(params)
		# updateModel(model, sbox)

		dosage_box =  estimateDosageRange(model, all_props, sbox)

		print('sat boxes', len(dosage_box), len(all_props)) #, bt)
	
		return dosage_box#, [], [])

	def getBoxDelta(b):
		# return b.min_side_width()*N_GRIDS 
		return max(b.min_side_width()*N_GRIDS, MIN_DELTA)
	
	def ifBoxEPS(b):
		return (b.max_side_width() < MIN_EPS)
	
	def estimateDosageRange(model, all_props, sbox):
		c_map = {}
		bmap = sbox.get_map()
		# i = 0
		# for it in bmap:
			# if i == 0:
		it = list(bmap.keys())[0]
		l, u = bmap[it].leftBound(), bmap[it].rightBound()
		# l, u = 0.0253125, 0.028297973899825753
		evaluate_dict = {}
		# for i in range(len(all_props)):
		p, pn1, pn2, mode = all_props[0]
		# min_prop = (p, pn2, mode)
		# max_prop = (p, pn1, mode)
		prop = (p, pn1, pn2, mode)
		stime =  time.time()
		lvr = getDosageEvaluation(model, sbox, prop, it, l, evaluate_dict) #evaluate(model, sbox, prop, it, l)
		etime = time.time()
		print('SAT', SAT, 'UNSAT', UNSAT, 'after lvr', etime - stime, 's', lvr)
		uvr = getDosageEvaluation(model, sbox, prop, it, u, evaluate_dict) #evaluate(model, sbox, prop, it, u)
		etime1 = time.time()
		print('SAT', SAT, 'UNSAT', UNSAT, 'after uvr', etime1 - etime, 's', uvr)
		print('getDoseLimit: finding minimum ', str(l), str(u), lvr, uvr)
		dose_l = getDoseLimit(model, sbox, prop, it, lvr, uvr, evaluate_dict,  minmax = -1)
		print('getDoseLimit: finding maximum ', str(l), str(u), lvr, uvr)
		sys.stdout.flush()
		dose_v = getDoseLimit(model, sbox, prop, it, lvr, uvr, evaluate_dict, minmax = 1)
		# dose_v = u
		l, u = dose_l.value, dose_v.value
		# lv, uv = Dosage(r1, dose_l), Dosage(r2, dose_v)
		print('dosage model', l, u)
		
		if u > l:
			c_map.update({it:PyInterval(l, u)})
			return [Box(c_map)]
		else:
			return []

	def des(r, rc):
		rt = True if r == SAT and rc == UNSAT else False
		# print('des', 'r', r, type(r), 'rc', rc, type(rc))
		return rt
		
	def desired(dv):
		r = dv.result[0]
		rc1 = dv.result[1]
		rc2 = dv.result[1]
		rt1 = des(r, rc1)
		rt2 = des(r, rc2)
		return rt1, rt2

	def specifc(dv):
		r = dv.result[0]
		rc1 = dv.result[1]
		rc2 = dv.result[1]
		# if minmax == -1:
		rt1 = True if rc1 == SAT and r == UNSAT else False
		rt2 = True if rc2 == SAT and r == UNSAT else False
		return rt1, rt2

	def evaluate(model1, sbox, prop, it, it_dose):
		# b_map = {}
		# b_map.update({it:PyInterval(it_dose)})
		# sb = Box(b_map)
		model = model1.clone()

		# updateModel(model, sb)
		# model1 = model.clone()
		# # for key in other_params:
		model.addInit(it, it_dose)
		# print('evaluate -- after model.init', model.init)
		# move this code before getEstimation...
		with open(temp_ha,'w+') as tfp:
			tfp.write(str(model))
		print('evaluate -- Step-6.5: temp model saved', temp_ha)

		#propNode = getSTL(prop)[0]
		(propNode, propNeg1, propNeg2, mode) = prop
		propN1 = getNegatedProperty(propNeg1) #, instance1)
		propN2 = getNegatedProperty(propNeg2) #, instance1)
		if DEBUG:
			print('In evaluate') #,\t prop : '+str(propNode)+'\n\t negProp : '+str(propNeg1) )
			print('@@ prop: '+ str(propNode),  str(propNeg1), str(propNeg2))
		ps = [(propNode, mode), (propN1, mode), (propN2, mode)]
		# negs = [0, 1, 2]
		inputs = [(model, ps[ij], MIN_DELTA, PATH_LEN, 0, 0, ij) for ij in range(3)]
		if POOL:
			pool = ProcessingPool(3)
			# inputs = [[model, all_props, allboxes[j], klen, j] for j in range(num_proc)]
			# 	#print(inputs)
			results = pool.map(checkproperty, inputs)
		else:
			results = [checkproperty(inputs[j]) for j in range(3)]

		if POOL:
			pool.close()
			pool.join()
			pool.clear()
		
		resij = [0, 0, 0]
		for jk in range(3):   
			res, ij = results[jk]
			(res1, i1, out1) = res
			resij[ij] = res1


		# print('\t evaluate --', it_dose)#, model.init)
		# (res1, i1, out1) = checkproperty(model, (propNode, mode), MIN_DELTA, PATH_LEN)
		# (res2, i2, out2) = checkproperty(model, (propN1, mode), MIN_DELTA, PATH_LEN, neg = 1)
		# (res3, i3, out3) = checkproperty(model, (propN2, mode), MIN_DELTA, PATH_LEN, neg = 2)		
		# resij  = [res1, res2, res3]

		return resij
		# sat1 = ''
		# #if res1==SAT:
		# #	in1 = getSAT(model, i1, neg = False)
		# #	sat1 = str(in1.getSATBox())
		# sat2 = ''
		# #if res2==SAT:
		# #	in2 = getSAT(model, i2, neg = True)
		# #	sat2 = str(in2.getSATBox())
		# sat3 = ''
		# # print('\t ----- des {0}, {1} ----'.format(des(res1, res2), des(res1, res3)), res1, res2, res3)
		# # print('\t ---- ', [str(c1) for c1 in propNode], res1, sat1)	
		# # print('\t ---- ', [str(c1)  for c1 in propN1], res2, sat2)
		# # print('\t ---- ', [str(c1)  for c1 in propN2], res3, sat3)
		# return resij #[res1, res2, res3]

	def getDosageEvaluation(model, sbox, prop, it, d, evaluate_dict):
		st1 = time.time()
		if d in evaluate_dict.keys():
			rv = evaluate_dict[d]
		else:
			rv = evaluate(model, sbox, prop, it, d)
			evaluate_dict.update({d:rv})
		dv = Dosage(rv, d) 
		
		sb_map = {}
		for it1 in sbox.get_map():
			sb_map.update({it1:sbox.get_map()[it1]})
		sb_map.update({it:PyInterval(d)})
		sb = Box(sb_map)
		ac_b =  getActualDosages(sb)
		print('\t --- simulated box -----', str(ac_b), d, rv)
		# ac_b_t4, ac_b_t3 = ac_b[0], ac_b[1]
		# g_pars_lb = []
		# # g_pars_ub = []
		# b_map = sb.get_map()
		# for key in sorted(b_map.keys()):
		# 	g_pars_lb.append(b_map[key].leftBound())
		# 	# g_pars_ub.append(b_map[key].rightBound())
		
		# # # fn  = temp_ha_preprocessed

		# print('\t --- simulated box -----', str(sb), sim.time)
		# all_values, all_time = sim.run(g_pars_lb, sim.time)
		# figs = sim.plot_output(all_values, all_time, plt_title=('SIM: LB: Dose {0:0.2f}, actual {1:0.2f}, raw {2:0.2f}, tsh range {3}'.format(g_pars_lb[0]*s_t4*777.0, ac_b_t4[0], g_pars_lb[0]*s_t4, (1.8*0.75, 1.8*1.25))))

		# all_values, all_time = sim.run(g_pars_ub, sim.time)
		# figs = sim.plot_output(all_values, all_time, plt_title=('UB: Dose {0:0.2f}, actual {1:0.2f}, raw {2:0.2f}, tsh range {3}'.format(g_pars_ub[0]*s_t4*777.0, ac_b_t4[0], g_pars_ub[0]*s_t4, (1.8*0.75, 1.8*1.25))))
				
		# rt = specifc(dv)
		# rt1 = desired(dv) #des(rv[0], rv[1])
		etime1 = time.time()
		print('\t getDosageEvaluation --',etime1 - st1, 's', d,  rv)#, rt)
		return dv

	def getDoseLimit(model, sbox, prop, it, lvr, uvr, evaluate_dict, minmax = -1):
		u1 = uvr.value
		l1 = lvr.value

		# lvr1 = lvr
		# uvr1 = uvr
		# if minmax == -1: # update the upper limit
		# 	print('- update upper --', minmax)
		# 	pre_uvr = lvr
		# 	u1 = l if l > 0 else l + 0.001
		# 	scale = 2.0
		# 	while u1 < u:
		# 		u1 = min(scale*u1, u)
		# 		# uvr = evaluate(model, sbox, prop, it, u1)
		# 		# if(pre_uvr[0] != uvr[0]):
		# 		# 	break	
		# 		uvr = getDosageEvaluation(model, sbox, prop, it, u1)
		# 		print('\t increase up {2} pre {0}, cur {1}'.format(pre_uvr, uvr, minmax), pre_uvr.result.p1, uvr.result.p1)
		# 		if not(pre_uvr.result.p1 == uvr.result.p1):
		# 			break
		# 		pre_uvr = uvr
		# 	# u1 = min(u, u1)

		# else: # update the lower limit
		# 	scale = 1.2
		# 	print('- update lower --', minmax)
		# 	pre_lvr = uvr
		# 	l1 = u
		# 	while l < l1:
		# 		l1 = max(l1/scale, l)
		# 		# lvr = evaluate(model, sbox, prop, it, l1)
		# 		# if(pre_lvr[0] != lvr[0]):
		# 		# 	break
		# 		lvr = getDosageEvaluation(model, sbox, prop, it, l1)
		# 		print('\t decrease low --{2} pre {0}, cur {1}'.format(pre_lvr, lvr, minmax), pre_lvr.result.p2, lvr.result.p2)
		# 		if not(pre_lvr.result.p2 == lvr.result.p2):
		# 			break
		# 		pre_lvr = lvr

		# lv = lvr # Dosage(lvr, l1) 
		# uv = uvr # Dosage(uvr, u1) 

		# lv, uv = l1, u1
		# v = -1
		# r = []
		r = Dosage()
		print('getDoseLimit --search ', minmax, 'lv',  (l1, lvr), 'uv', (u1, uvr))
		sys.stdout.flush()
		while(lvr.value <= uvr.value):
			# print(' -- in loop ', minmax, 'lv', lvr, 'uv',uvr, (minmax == -1 and not(lvr.result.p2 == uvr.result.p2)), ((minmax == 1 and not(lvr.result.p1 == uvr.result.p1))))
			if (not(lvr.result.p1 == uvr.result.p1) or  not(lvr.result.p2 == uvr.result.p2)):	
				d1 = (uvr.value - lvr.value)
				md = (lvr.value + uvr.value)/2
				if( d1 < MIN_EPS):				
					print('< delta (', d1, ') : ', 'lv', (lvr), 'uv', (uvr))
					if lvr.result.p1 == UNSAT and lvr.result.p2 == UNSAT:
						# v = l1
						print('select lvr')
						r = lvr
						# break
					elif uvr.result.p1 == UNSAT and uvr.result.p2 == UNSAT:
						# v = u1
						print('select uvr')
						r = uvr
						# break	
					else:
						mvr = getDosageEvaluation(model, sbox, prop, it, md, evaluate_dict)
						print('select mvr', mvr)
						r = mvr
					break
				else:	
					sys.stdout.flush()
					# mr = evaluate(model, sbox, prop, it, md)
					# mv = Dosage(mr, md)
					mvr = getDosageEvaluation(model, sbox, prop, it, md, evaluate_dict)

					if minmax == -1: # for minimum
						if(mvr.result.p2 == SAT):# and not mvr.result.p0==UNSAT): # p2: tsh > max 
							# u1 = md  
							mr = [mvr.result.p0, mvr.result.p1, mvr.result.p2]
							lvr = Dosage(mr, md)
						else:
							# l1 = md
							mr = [mvr.result.p0, mvr.result.p1, mvr.result.p2]
							uvr = Dosage(mr, md)
							#lvr = mvr
					else: # for maximum
						if(mvr.result.p1==SAT):#and not mvr.result.p0==UNSAT): # p1 : tsh < min
							# l1 = md
							mr = [mvr.result.p0, mvr.result.p1, mvr.result.p2]
							uvr = Dosage(mr, md) 
							# lvr = mvr 
						else:
							# u1 = md
							mr = [mvr.result.p0, mvr.result.p1, mvr.result.p2]
							lvr = Dosage(mr, md)
							# uvr = mvr
					
					print("search: ", minmax, 'lv', (lvr), 'mv', (mvr), 'uv', (uvr))	
					
			else:
				print("drug dosage not found for the model", r)
				sys.stdout.flush()
				break; 
		return r


	ha2 = getModel(inputfile)
	if DEBUG:
		print('Step-1: model parsed ...') #, str(ha1))

	res_header = ['row','hypo_obs_TSH','hypo_obs_FT4','hypo_c_TSH','hypo_c_FT4', 'd_1','LT4', 'eu_base_TSH', 'eu_base_FT4','eu_sp_TSH','eu_sp_FT4']
	res_csv = open(all_res_file, 'a+')
	wr = ['{0}'.format(rr) for rr in res_header]+ ['dose_c']
	res_writer = csv.writer(res_csv, delimiter=',')
	res_writer.writerow(wr)
	res_csv.close()

	figs_to_plot = []
	ijk = 0
	for ss_rn in sskm_rows_keys: #sskm_rows.keys():
		# ss_rn, ss_cl = rn_cl
		hypo_params, rf = sskm_rows[ss_rn]
		print('sskm_rows', ss_rn, rf)

		# inputs = [(model, p1, MIN_DELTA, PATH_LEN, False), (model, p2, MIN_DELTA, PATH_LEN, True), (model, p3, MIN_DELTA, PATH_LEN, True)]
		# if POOL:
		# 	pool = ProcessingPool(3)
		# 	# inputs = [[model, all_props, allboxes[j], klen, j] for j in range(num_proc)]
		# 	# 	#print(inputs)
		# 	results = pool.map(checkproperty, inputs)
		# else:
		# 	results = [checkproperty(inputs[j]) for j in range(3)]

		# if POOL:
		# 	pool.close()
		# 	pool.join()
		# 	pool.clear()
		# # for jk in range(3):   
		# p11, res1 = results[jk]
		ha1 = ha2.clone()
		# ha1 = ha11 #.simplify()
		for ik in range(len(hypo_params)):
			hypo_par_name, hypo_par_val = hypo_params[ik]
			hpv = getExpression(('{0}'.format(hypo_par_val)))
			# ha1.macros[hypo_par_name] = hpv
			ha1.macros.update({hypo_par_name:hpv})
			# print('macros', hypo_par_name, hypo_par_val)
		stm = time.time()
		print('#### -------------------------- for row {0} -----'.format(ss_rn), rf['LT4'], rf['hypo_obs_TSH'], rf['hypo_c_TSH'], rf['eu_base_TSH'], rf['eu_sp_TSH'])
		print('--- model initialisation ---')
		for key in ha1.macros.keys():
			print('--- {0} : {1} ---'.format(str(key), str(ha1.macros[key])))
		print('-------------------------')
		NumModes = len(ha1.states)
		# global PATH_LEN	
		#k_length = 30*NumModes if NumModes > 1 else 2
		ijk += 1
		# if ijk > 2:
		# 	break

		# results = evaluate(ha1, all_props, allboxes[j], klen, 0)
		def getPF(tg1):
			if tg1 == 24.0:
				p = 1.2
				f = 1.2957
			elif tg1 == 12.0:
				p = 0.6
				f = 1.201996
			elif tg1 == 8.0:
				p = 0.4
				f = 1.1729
			else:
				p = 1.0/20 #2*tg_t4/N
				f = 4.0
			return p, f

		#tg_t4, tg_t3, p43, p45, s_t4, s_t3  = ha1.getMacroValues(['tg_t4', 'tg_t3', 'p_43', 'p_45', 's_t4', 's_t3'])
		#tg_t4, tg_t3, p43, p45, s_t4, s_t3 = float(tg_t4), float(tg_t3), float(p43), float(p45), float(s_t4), float(s_t3)
		
		tg_t4, tg_t3, p43, p45, s_t4, s_t3, s_0  = ha1.getMacroValues(['tg_t4', 'tg_t3', 'p_43', 'p_45', 's_t4', 's_t3', 's0'])
		p43, p45, s_t4, s_t3, s_0 = float(p43), float(p45), float(s_t4), float(s_t3), float(s_0)
		tg_t4, tg_t3 = float(tg_t4.replace('s0', str(s_0))), float(tg_t3.replace('s0', str(s_0)))
		eps_1, delta_1 = getPF(tg_t4)
		eps_2, delta_2 = getPF(tg_t3)

		# if DEBUG:
		print('Step-2: macros', tg_t4, tg_t3, p43, p45, eps_1, eps_2, delta_1, delta_2, s_t4, s_t3)

		def getFourierFunction(tg_t4, tg_t3, p_43, p_45, eps_1, eps_2, delta_1, delta_2):
			SIMPLE = TRUE
			# Nterms = 5			
			sage.var('et4s', 'et3s', 'off_t3', 'off_t4', 'q_0s')

			if SIMPLE:
				(fn, f1, f2, a0) = drug_four.getFourierSimple(Nterms, eg)
				# a0 = eval('a0+off')
			else:
				(fn, f1, f2, a0) = drug_four.getFourier(Nterms)
				# a0 = eval('a0+off')
			
			#dfn = getFourierDerivative(fn)
			pfr_t4 = fn(t_gap = tg_t4, k_a = p_43, pi=math.pi, off = 0, d0 = et4s, eps = eps_1, delta = delta_1)
			defs_t4 = drug_four.getFourierDerivative(pfr_t4)	
			defs_4 = defs_t4(tm = q_0s)
			pfr_t4 = pfr_t4(tm = q_0s)
			# inita_t4 = a0(t_gap = tg_t4, k_a = p_43, pi=math.pi, off = 0, d0 = et4s, eps = eps_1, delta = delta_1)
			# initf_t4 = pfr_t4(tm = 0) #+ off_t4
			initf_t4 = f2(tm = 0, t_gap = tg_t4, k_a = p_43, pi=math.pi, off = 0, d0 = et4s, eps = eps_1, delta = delta_1) 
			#(dose_t4/(p_43*tg_t4))
			
			#print("four ", pfr, "\n derivative: ",toString(defs),"\n der: ", toString(defs2), "\n init: ", toString(inita) , "\n initf: ", toString(initf))
			#print("four ", pfr_t4, "\n derivative: ",toStr(defs_t4),"\n initf: ", toStr(initf_t4))
			
			# print('\n T4 derivative of fourier: \n')
			# print(defs_t4)
			# print(inita_t4, initf_t4)
			
			pfr_t3 = fn(t_gap = tg_t3, k_a = p_45, pi=math.pi, off = 0, d0 = et3s, eps = eps_2, delta = delta_2)
			defs_t3 = drug_four.getFourierDerivative(pfr_t3)
			defs_3 = defs_t3(tm = q_0s)
			pfr_t3 = pfr_t3(tm = q_0s)
			#defs2 = dfn(t_gap = tg, k_a = ka, eps = p, pi=math.pi, delta= f, off = 0)
			# inita_t3 = a0(t_gap = tg_t3, k_a = p_45, pi=math.pi, off = 0, d0 = et3s, eps = eps_2, delta = delta_2)
			# initf_t3 = pfr_t3(tm = 0) #+ off_t3
			initf_t3 = f2(tm = 0, t_gap = tg_t3, k_a = p_45, pi=math.pi, off = 0, d0 = et3s, eps = eps_2, delta = delta_2)
			#initf_t3 = (dose_t3/(p_45*tg_t3))
			#print("four ", pfr, "\n derivative: ",toString(defs),"\n der: ", toString(defs2), "\n init: ", toString(inita) , "\n initf: ", toString(initf))
			#print("four ", pfr_t3, "\n derivative: ",toStr(defs_t3),"\n initf: ", toStr(initf_t3))
			
			# print('\n T3 derivative of fourier: \n')
			# print(defs_t3)
			# print(inita_t3, initf_t3)

			# var('et4, et3')
			# (fet1, chk1) = getRange(p1, N, tg_t4)
			# (fet2, chk2) = getRange(p2, N, tg_t3)	
			# fn1 = fn(t_gap = tg_t4, k_a = p_43, eps = p1, d0 = et4, pi=math.pi, delta = f1, off = 0)
			# fn2 = fn(t_gap = tg_t3, k_a = p_45, eps = p2, d0 = et3, pi=math.pi, delta = f2, off = 0)
			
			# #print(fn, fn1)
			# #sys.stdout.flush()

			# (off_t3, tm1) = getOffset(fn1, tg_t4 - fet1, chk1)
			# (off_t4, tm2) = getOffset(fn2, tg_t3 - fet2, chk2)

			init_et4 = initf_t4(tg_t4 = tg_t4, p_43 = p_43, t_gap = tg_t4, k_a = p_43, eps_t4 = eps_1, dose_t4 = et4s, pi=math.pi, delta_t4 = delta_2)#, off_t4 = offset1)
			init_et3 = initf_t3(tg_t3 = tg_t3, p_45 = p_45, t_gap = tg_t3, k_a = p_45, eps_t3 = eps_2, dose_t3 = et3s, pi=math.pi, delta_t3 = delta_2)#, off_t3 = offset2)
		
			return fn, pfr_t4, pfr_t3, defs_4, defs_3, init_et4, init_et3

		fn_four, pfr_t4, pfr_t3, defs_t4, defs_t3, initf_t4, initf_t3 = getFourierFunction(tg_t4, tg_t3, p43, p45, eps_1, eps_2, delta_1, delta_2)

		print('replace', tg_t4, tg_t3, p43, p45)
		print('defs_t4', pfr_t4)
		dt4 = getExpression(('{0}'.format(defs_t4)).replace('tm', '(q_0s)').replace('e^', 'exp'))
		dt3 = getExpression(('{0}'.format(defs_t3)).replace('tm', '(q_0s)').replace('e^', 'exp'))
		#dt4 = getExpression(('{0}'.format(pfr_t4)).replace('e^', 'exp'))#.replace('q_0s', 'tm'))
		#dt3 = getExpression(('{0}'.format(pfr_t3)).replace('e^', 'exp')) #.replace('q_0s', 'tm'))
		et4_in = getExpression('{0}'.format(initf_t4))
		print('defs_t4', dt4)
		# et3_in = getExpression('{0}'.format(initf_t3))
		# ha1.macros['dose_t4'] = dt4
		# ha1.macros['dose_t3'] = dt3
		# ha1.macros['et4_init'] = et4_in
		# ha1.macros['et3_init'] = et3_in

		ha1.macros.update({'dose_t4':dt4})
		ha1.macros.update({'dose_t3':dt3})
		ha1.macros.update({'et4_init':et4_in})
		# ha1.macros.update({'et3_init':et3_in})

		if DEBUG:
			print('Step-3: replace macros 1')#, str(ha1))

		def getActualDosages(dose_Box): #, tg_t4, tg_t3, p43, p45, eps_1, eps_2, delta_1, delta_2):
			dose_l = dose_Box.min_left_coordinate_value()
			dose_u = dose_Box.max_right_coordinate_value()
			# dose_t4, dose_t3 = params
			#(off1, ffs1, p1, f1, tm1) = optimizeSmootherfunction(N, tg_t4, p_43, dose_t4)
			# print(p1, f1)
			#(off2, ffs2, p2, f2, tm2) = optimizeSmootherfunction(N, tg_t3, p_45, dose_t3)
			# print(p2, f2)
			dt4_l, dt4_u = dose_l['et4']*s_t4, dose_u['et4']*s_t4
			# dt3_l, dt3_u = dose_l['et3s']*s_t3, dose_u['et3s']*s_t3

			off_t4 = 0, 0 #(0.1*(dt4_l/(1 - np.exp(-p43 * tg_t4)))), (0.1*(dt4_u/(1 - np.exp(-p43 * tg_t4))))
			# off_t3 = (0.1*(dt3_l/(1 - np.exp(-p45 * tg_t3)))), (0.1*(dt3_l/(1 - np.exp(-p45 * tg_t3))))

			# (r4_l, res4_l) = sagec.getSSActual(fn_four, tg_t4, p43, eps_1, 1.0, delta_1, dt4_l, off_t4[0])
			# (r4_u, res4_u) = sagec.getSSActual(fn_four, tg_t4, p43, eps_1, 1.0, delta_1, dt4_u, off_t4[1])
			r4_l = dt4_l
			r4_u = dt4_u
			# (r4_l, res4_l) = sagec.getactualValue(Nterms, tg_t4, p43, eps_1, 1.0, delta_1, dt4_l, off_t4[0])
			# (r4_u, res4_u) = sagec.getactualValue(Nterms, tg_t4, p43, eps_1, 1.0, delta_1, dt4_u, off_t4[1])
			# (r3_l, res3_l) = sagec.getactualValue(Nterms, tg_t3, p45, eps_2, 1.0, delta_2, dt3_l, off_t3[0])
			# (r3_u, res3_u) = sagec.getactualValue(Nterms, tg_t3, p45, eps_2, 1.0, delta_2, dt3_u, off_t3[1])
			res = ((r4_l*777, r4_u*777), (0, 0)) #(r3_l*651, r3_u*651))
			return res

		outputEqns1 = getEquationsFile(outputfile)
		for var in outputEqns1:
			print(var + ' : '+ str(outputEqns1[var]))
			ha1.macros.update({var:outputEqns1[var]})

		outputEqns = {}
		for var in outputEqns1.keys():
			expr = outputEqns1[var]
			for key in reversed(ha1.macros.keys()):
				expr = expr.replace(key, ha1.macros[key])
			for key in ha1.macros.keys():
				expr = expr.replace(key, ha1.macros[key])
			outputEqns.update({var:expr})

			print('updated '+ var + ' : '+ str(outputEqns[var]))

		# if DEBUG:
		print('Step-4: replace outputEqns 2') #, str(ha1))
		print('Step-5: HA before simplify')
			#print(str(ha1))

		sys.stdout.flush()
		ha = ha1.simplify(skip = ['dose_t4', 'dose_t3', 'q_10s']) 
		# if DEBUG:
		print('Step-6: HA after simplify')
		# print(str(ha.macros))
		temp_ha = inFileName+'_'+suf+'temp_{0}.drh'.format(index)
		temp_ha_preprocessed = inFileName+'_'+suf+'temp_{0}.preprocessed.drh'.format(index)
		print(temp_ha)
		with open(temp_ha, 'w+') as tfp:
			tfp.write(str(ha))

		sys.stdout.flush()

		#simulateFile = 'simulateHA_{0}.py'.format(index)
		#sim_ha = hode.createSimulator(datafile, temp_ha, outputfile, 0.001, paramdefaultfile)
		#f = open(simulateFile, "w+")
		#f.write(sim_ha)
		#f.close()
		#import simulateHA_1 as sim
		
		#default_params = sim.getDefaultParams()
		#param_names = sim.getParamNames()		
		#print('default_params', param_names, default_params)

		print('Step-6.5: temp model saved')
		'''detect parameters'''
		#if DEBUG:
		print('Step-7: model parsed', time.time() - stm, 's')
		sys.stdout.flush()
		if TEST:
			exit()
		
		all_params = {}
		if not paramfile == '':
			all_params = getParam(paramfile)
		else:
			inits = {}
			for c in ha.init.condition:
				# print(str(c.literal1), str(c.literal2))
				inits.update({str(c.literal1):str(c.literal2)})

			for var in ha.variables.keys():
				if var == 'time':
					continue
				rng = ha.variables[var]
				if var in all_params.keys() or var not in inits.keys():
					all_params.update({var:rng})

		
		'''detect parameters'''
		for par in all_params:
			print(par + ' : '+ str(all_params[par]))
		
		sys.stdout.flush()
		#dataSet = Data(datafile)

		#print(str(pha))

		# param_len = 2 
		param_len = len(all_params.keys())
		subsets_2 = findsubsets(list(all_params.keys()), param_len)
		
		#if PLOT:

		# for sub in subsets_2: #for each subset of size 2 

		sub = list(subsets_2)[0]
		print('For param set', sub, type(sub))
		params = {}
		other_params = {}
		for key in all_params:
			# print(key)
			if key in sub:
				params.update({key:all_params[key]})
				# d_iv = '(0.5*({0}+{1}))'.format(all_params[key].getleft(), all_params[key].getright())
			else:
				other_params.update({key:all_params[key]})
				#pha.addInit(key, all_params[key])
				print('params fixed: ', key, str(all_params[key]))

		pha = convertHA2PHA(ha, params)
		for key in other_params:
			pha.addInit(key, other_params[key])
		print('params', [str(params[k]) for k in params.keys()])
		print('model parameters', str(pha.parameters))
		
		sys.stdout.flush()
		#eu_sp_TSH,eu_sp_FT4,eu_base_TSH,eu_base_FT4
		# fixed_obs1 = rf['TSH_eu'], rf['FT4_eu']
		# fixed_obs = rf['TSH_es'], rf['FT4_es']
		fixed_obs1 = rf['eu_sp_TSH'], rf['eu_sp_FT4']
		fixed_obs = rf['eu_base_TSH'], rf['eu_base_FT4']
		#(satparam, unsatparam, undetparam) = getEstimatedParameters(pha, params, dataSet, d, k)
		satparam = getEstimatedParameters(pha, params, d, k_length, datafile, (fixed_obs, fixed_obs1), outputEqns)
		ac_b =  getActualDosages(satparam[0]) if len(satparam) > 0 else  -1
		res_csv = open(all_res_file, 'a+')
		wr = ['{0}'.format(rf[rr]) for rr in res_header]+ [ac_b]

		res_writer = csv.writer(res_csv, delimiter=',')
		res_writer.writerow(wr)
		print('########## row {0} given {1} calculated {2}'.format(ss_rn, rf['LT4'], satparam, rf))
		sys.stdout.flush()
		res_csv.close()

		print('SAT boxes ---')
		with open(outfile, 'a+') as csvfile:
			spamwriter = csv.writer(csvfile, delimiter=',')
			i = 0
			names = []
			for b in satparam:
				b_map = b.get_map()
				row = ['data']
				for key in sorted(b_map.keys()):
					row.append(key+'_low')
					row.append(key+'_up')
					names.append(key)
				i += 1			
				spamwriter.writerow(row)
				if i > 0:
					break

			xdata = []
			for b in satparam:
				ac_b =  getActualDosages(b)
				print('getActualDosages', ac_b)
				b_map = b.get_map()
				g_pars_lb = []
				g_pars_ub = []
				row = []
				xr = []
				for key in sorted(b_map.keys()):
					#row.append((float(b_map[key].leftBound()), float(b_map[key].rightBound())))
					row.append(float(b_map[key].leftBound()))
					row.append(float(b_map[key].rightBound()))
					mid_pt = (b_map[key].leftBound()+b_map[key].rightBound())/2
					xr.append(mid_pt)
					g_pars_lb.append(b_map[key].leftBound())
					g_pars_ub.append(b_map[key].rightBound())

				# all_values, all_time = sim.run(g_pars_lb, sim.time)
				# ac_b_t4, ac_b_t3 = ac_b[0], ac_b[1]
				# figs = sim.plot_output(all_values, all_time, plt_title=('{0:0.2f}={1:0.2f}, {2:0.2f}'.format(g_pars_lb[0]*s_t4*777.0, ac_b_t4[0], g_pars_lb[0]*s_t4)))
				# plt.title('row {0} minimum {1}'.format(ss_rn, str(g_pars_lb)))
				# for fig in figs:
				# 	figs_to_plot.append(fig)
				# 	# pp.savefig(fig)
				# all_values, all_time = sim.run(g_pars_ub, sim.time)
				# figs = sim.plot_output(all_values, all_time, plt_title=('{0:0.2f}={1:0.2f}, {2:0.2f}'.format(g_pars_ub[0]*s_t4*777.0, ac_b_t4[1], g_pars_ub[0]*s_t4)))
				# plt.title('row {0} maximum {1}'.format(ss_rn, str(g_pars_ub)))
				# for fig in figs:
				# 	figs_to_plot.append(fig)

				row.append(TRUE)
				xdata.append(xr)
				spamwriter.writerow(row)
			# for b in unsatparam:
			# 	b_map = b.get_map()
			# 	row = []
			# 	for key in sorted(b_map.keys()):
			# 		#row.append((float(b_map[key].leftBound()), float(b_map[key].rightBound())))
			# 		row.append(float(b_map[key].leftBound()))
			# 		row.append(float(b_map[key].rightBound()))
			# 	row.append(FALSE)
			# 	spamwriter.writerow(row)

			i += 1
		print('##################################')
		# break
		# if PLOT:
		sbox = getBox(params)
		x_scale = [1.0, 1.0]
		b_edges = sbox.get_map()
		lb = len(b_edges)
		# n_combs = []
		keys = sorted(b_edges.keys())
		n_combs = findsubsets(keys, 2)
		#for sub in subsets_2:
		c = 0
		for combs in n_combs:
			x = []
			w = []
			axisname = []
			i = 0
			for it in combs:
				s = x_scale[i]
				intrvl = b_edges[it]
				x.append(intrvl.leftBound()*s)
				w.append(intrvl.width()*s)
				axisname.append(it)
				i += 1
			fig_t = plt.figure()
			xlim = [0.9*x[0], 1.1*(x[0] + w[0])]
			ylim = [0.9*x[1], 1.1*(x[1] + w[1])]
			# print(xlim, ylim)
			plt.xlabel(axisname[0])
			plt.ylabel(axisname[1])
			# plt.ylim()
			# # plt.axhline(y=x[1], xmin=x[0], xmax=x[0]+w[0])
			# plt.axhline(y=x[1]+w[1], xmin=x[0], xmax=x[0]+w[0])
			# plt.axvline(x=x[0], ymin=x[1], ymax=x[1]+w[1])
			# plt.axvline(x=x[0]+w[0], ymin=x[1], ymax=x[1]+w[1])
			currentAxis = plt.gca()
			currentAxis.set_xlim(xlim)
			currentAxis.set_ylim(ylim)
			
			#X = [xdata[i][combs[0]] for i in range(xdata)]
			#Y = [xdata[i][combs[1]] for i in range(xdata)]

			print('SAT ---', c)
			i = 0
			for b in satparam:
				b_edges = b.get_map()
				b1_edges = {}
				for it in combs:
					b1_edges.update({it:b_edges[it]})
				b1 = Box(b1_edges)
				#print('class: ', str(p))
				# for b in b1:
				# print(str(b), b.max_side_width(), EPS)
				plotBox(currentAxis, b1, combs, TRUE)
				i+= 1
			# print(i)

			figs_to_plot.append(fig_t)
			# pp.savefig(fig_t)
			c+= 1
		# if PLOT:

	res_csv.close()
	pp = PdfPages(plotName)
	for fig in figs_to_plot:
		pp.savefig(fig)
	pp.close()
		
def getPropSMT(tp, pid, i, neg):
	fn ='temp_'+suf+'{0}_'.format(index)+str(tp)+'_'+str(rank)+'_'+str(pid)+'_'+str(i)
	if neg == 1:
		fn = 'tempC1_'+suf+'{0}_'.format(index)+str(tp)+'_'+str(rank)+'_'+str(pid)+'_'+str(i)
	elif neg == 2:
		fn = 'tempC2_'+suf+'{0}_'.format(index)+str(tp)+'_'+str(rank)+'_'+str(pid)+'_'+str(i)
	return fn
	
def getSAT(model, i, tp = 0, pid = 0, neg = False):
	# if neg:
	# if neg:
	# 	fn = 'tempC_p_'+str(rank)+'_'+str(pid)+'_'+str(i)
	# else:
	# 	fn = 'temp_p_'+str(rank)+'_'+str(pid)+'_'+str(i)
	# fname = os.path.join(tempfolder, fn+'.smt2.model')

	fn = getPropSMT(tp, pid, i, neg)
	fname = os.path.join(tempfolder, fn+'_0_0.smt2.model')
	#print('getSAT', fname)
	if DEBUG:
		print('Reading sat instance :', fname)
	satinstance = parseInstance(fname)
	#print(satinstance.variables[0])
	satinstance.addModel(model)
	satinstance.addDepth(i)
	return satinstance
	
# checkproperty(model, (propNeg, mode), MIN_DELTA, PATH_LEN, neg = True)
def checkproperty(params):
	model, prop_mode, delta, klen, tp, pid, neg = params
	# def checkproperty(model, prop_mode, sbox, delta, klen, tp, pid = 0, neg = False):
	prop, mode = prop_mode[0], str(prop_mode[1])
	#g = model.getGraph()
	st = model.init.mode
	# s = ''
	# for it in model.variables:
	# 	s += it + ':' + str(model.variables[it])+ ' , '
	# print('##checkproperty', 'model.variables: ', s, 'model.init', str(model.init), 'model -- props')
	#smts = []
	i = 0
	res = (UNSAT, i, '')
	model.addGoals(mode, prop)
	fn = getPropSMT(tp, pid, i, neg)
	#print(fn)
	fname = os.path.join(tempfolder, fn+'.drh')
	fname_pp = os.path.join(tempfolder, fn+'.preprocessed.drh')
	with open(fname, 'w+') as of:
		of.write(str(model))
	# print('checkproperty', fname)
	# st = [dReachCmd, "-k", str(klen), "-z", fname, "--precision", str(delta), "--model"] 

	# st = [dReachCmd, "-k", str(klen), "-z", fname, "--precision", str(delta), "--ode-step", str(0.001), "--model"] 
	st = [dReachCmd, "-k", str(klen), "-z", fname, "--precision", str(delta), '--ode-cache',"--model"] 
	#st = [dReachCmd, "-k", str(klen), "-z", fname, "--precision", str(delta), "--model"] 
	# st = [dReachCmd, "-k", str(klen), "-z", fname, "--precision", str(delta), '--parallel', '--ode-parallel', "--model"] #--ode-step", str(0.2), '--ode-cache', '--parallel', '--ode-parallel', '--model']
	if DEBUG:
			print('\t----- '+str(st))
	#print('\t----- '+str(st))
	# p = subprocess.Popen(st, stdout=subprocess.PIPE)
	# (output, err) = p.communicate(timeout=1200)  
	'''This makes the wait possible'''
	# p_status = p.wait()	
	# out = p_status

	# p = subprocess.run(st) #, capture_output=True)
	try:
		output =  subprocess.check_output(st) #, timeout=12*3600)
		out = 0
	except subprocess.CalledProcessError as e:
		out = e.returncode
		output = e.stdout
	except Exception as e:
		print('Running call again....')	
		if DEBUG:
			print('\t----- '+str(st))
		# print('\t----- '+str(st))
		# p = subprocess.Popen(st, stdout=subprocess.PIPE)
		# (output, err) = p.communicate(timeout=1200)  
		'''This makes the wait possible'''
		# p_status = p.wait()	
		# out = p_status

		# p = subprocess.run(st) #, capture_output=True)
		try:
			output =  subprocess.check_output(st)
			out = 0
		except subprocess.CalledProcessError as e:
			out = e.returncode
			output = e.stdout
	if DEBUG:
		print('dReal res:', out, output)

	# start_time = time.time()
	
	# end_time = time.time()

	# if end_time - start_time:
	# 	p.kill()
	# 	print('Killed following call to dReal... ')#, st)
	# 	print('Running call again....')	
	# 	print('\t----- '+str(st))
	# 	(output, err) = p.communicate()
	# 	'''This makes the wait possible'''
	# 	p_status = p.wait()	

	'''This will give you the output of the command being executed'''
	if DEBUG:
		print ("\t----- Output: " + str(out), 'depth ', klen)#, 'out', output)		
	
	sys.stdout.flush()
	
	if(out == SAT or b'delta-sat' in output):
		if DEBUG:
			print('delta-sat', SAT)
		res = (SAT, i, output)
		return res, neg #, fname_pp
	elif(out == UNSAT or b'unsat' in output):
		if DEBUG:
			print('unsat')
		res = (UNSAT, i, '')
		return res, neg #, fname_pp
	else:				
		res = (UNKNOWN, i, '')
		if DEBUG:
			print('ERROR')
		return res, neg #, fname_pp
	#for path in g.getPathsofLength(st, mode, klen): 
	# for path in g.getKPaths(st, klen):
	# 	#print('checkproperty', path)
	# 	depth = len(path)
	# 	#smt = ''
	# 	cp_t1 = time.time()
	# 	smtEncode = smten.generateSMTforPath(model, path, delta)	
	# 	propertySmt = to_SMT(prop, smtEncode)
	# 	#propertySmtneg = Node(prop).negate().toSMT()
	# 	#if(neg):
	# 	#	smtEncode.addGoal(propertySmtneg)
	# 	#else:
	# 	smtEncode.addGoal(propertySmt)			
	# 	smt = smtEncode.toString(neg)
		
	# 	#print('checkproperty', propertySmt, time.time() - cp_t1, 's')
	# 	# print('2.######')
	# 	#if(i == 1):
	# 	#	break
	# 	fn = getPropSMT(tp, pid, i, neg)
	# 	#print(fn)

	# 	fname = os.path.join(tempfolder, fn+'.smt2')
	# 	with open(fname, 'w') as of:
	# 		of.write(smt)
	# 	i +=1		
	# 	#sys.stdout.flush()
		
	# 	st = [dRealCmd, fname, "--precision", str(delta), "--ode-step", str(0.5), '--ode-cache', '--parallel', '--ode-parallel', '--model']
	# 	#st = [dRealCmd, fname, "--precision", str(delta), "--ode-step", str(0.2), "--model"]
	# 	# st = [dRealCmd, fname, "--precision", str(delta), "--model"]
		
	# 	if DEBUG:
	# 		print('\t----- '+str(st))
	# 	#print('\t----- '+str(st))
	# 	# p = subprocess.Popen(st, stdout=subprocess.PIPE)
	# 	# (output, err) = p.communicate(timeout=1200)  
	# 	'''This makes the wait possible'''
	# 	# p_status = p.wait()	
	# 	# out = p_status

	# 	# p = subprocess.run(st) #, capture_output=True)
	# 	try:
	# 		output =  subprocess.check_output(st, timeout=6*3600)
	# 		out = 0
	# 	except subprocess.CalledProcessError as e:
	# 		out = e.returncode
	# 		output = e.stdout
	# 	except Exception as e:
	# 		print('Running call again....')	
	# 		if DEBUG:
	# 			print('\t----- '+str(st))
	# 		try:
	# 			output =  subprocess.check_output(st)
	# 			out = 0
	# 		except subprocess.CalledProcessError as e:
	# 			out = e.returncode
	# 			output = e.stdout
	# 	if DEBUG:
	# 		print('dReal res:', out, output)

	# 	# start_time = time.time()
		
	# 	# end_time = time.time()

	# 	# if end_time - start_time:
	# 	# 	p.kill()
	# 	# 	print('Killed following call to dReal... ')#, st)
	# 	# 	print('Running call again....')	
	# 	# 	print('\t----- '+str(st))
	# 	# 	(output, err) = p.communicate()
	# 	# 	'''This makes the wait possible'''
	# 	# 	p_status = p.wait()	

	# 	'''This will give you the output of the command being executed'''
	# 	if DEBUG:
	# 		print ("\t----- Output: " + str(out), 'depth ', depth)#, 'out', output)		
		
	# 	sys.stdout.flush()
		
	# 	if(out == 0 and b'delta-sat' in output):
	# 		if DEBUG:
	# 			print('delta-sat', SAT)
	# 		return (SAT, i-1, output)
	# 	elif(out == 0 and b'unsat' in output):
	# 		if DEBUG:
	# 			print('unsat')
	# 		res = (UNSAT, i-1, '')
	# 	else:				
	# 		res = (UNKNOWN, i-1, '')
	# 		if DEBUG:
	# 			print('ERROR')
	# 		return res
	# return res	
		

def updateModel(model, sbox):
	#print('updateModel', box, 'model.params: ')
	#for it in model.parameters:
	#	print(it, str(model.parameters[it]))
	edges = sbox.get_map()
	for it in edges:
		intrvl = edges[it]
		if DEBUG:
			print('InUpdate Model: ', intrvl.leftBound(), str(intrvl.leftBound()))
		param = Range(Node(intrvl.leftBound()), Node(intrvl.rightBound()))
		if it in model.parameters:
			model.parameters.update({it: param})
		if it in model.variables:
			model.variables.update({it: param})
	s = ''
	for it in model.parameters:
		s += it + ':' + str(model.parameters[it])+ ' , '
	if DEBUG:
		print('updatedModel', 'model.params: ', s)
	#return model
		
'''
In case of adjacent sat instances.. divide the box through the adjacent dimension
intersecting boxes -- error box -- remove it
smaller box -- cover it and remove
otherwise, divide along the middle point

'''
def heuristicPartition(sbox, instance, delta):
	boxesWPriority = []
	boxes = []
	
	inst1 = instance.p1
	inst2 = instance.p2
	
	point = inst1.getSATPoint()
	negpoint = inst2.getSATPoint()

	satb = inst1.getSATBox()
	negsatb = inst2.getSATBox()

	if DEBUG:
		print(sbox, 'point:', point, 'negpoint:', negpoint)
	
	if point.empty() or negpoint.empty():
		return []

	# global noise
	emap = {}
	b_map = sbox.get_map()
	for it in b_map.keys():		
		# emap.update({it: PyInterval(0.01 * noise[it])})
		emap.update({it: PyInterval(delta, delta)})

	adjacentEdges = satb.adjacentEdges(negsatb)
	adjacent = False
	if len(adjacentEdges) > 0:
		for it in adjacentEdges:
			#print('adjacent', it)
			intrvl = b_map[it]
			intrvl.mark()
		adjacent = True
	#emap = {}
	#b_map = sbox.get_map()
	#for it in b_map.keys():		
	#	emap.update({it: PyInterval(EPS)})
	
	if DEBUG:
		print('heuristicPartition: Box = ', str(sbox)) 
	
	''' middle point between propSat and propNegSat '''
	mPoint = middlePoint(point, negpoint) 
	boxes = bfact.bisect(sbox, emap, NOMARK)#, mPoint) #negpoint)

	# b3 = bfact.boxIntersection(satb, negsatb)
	
	if satb.adjacent(negsatb) or satb.intersects(negsatb):
		# boxes = bfact.bisect(sbox, emap, NOMARK, negpoint)
		for b in boxes:
			if(not b.empty()):
				if len(boxes) == 1:
					item = (3, b) # not divided anymore
				else:
					item = (2, b)
				boxesWPriority.append(item)
	# #elif satb.fullyContains(b3) and negsatb.fullyContains(b3):
	# elif satb.intersects(negsatb):	
	# 	for b in boxes:
	# 		if(not b.empty()):
	# 			if len(boxes) == 1:
	# 				item = (3, b)
	# 			else:
	# 				item = (2, b)
	# 			boxesWPriority.append(item)
	else:
		for b in boxes:
			if(not b.empty()):
				if len(boxes) == 1:
					item = (3, b)
				else:
					item = (1, b)
				boxesWPriority.append(item)
	#print('heuristicPartition - boxes', len(boxes), len(boxesWPriority))
	return boxesWPriority
	
def getNegatedProperty(prop, instance = None):	
	#print('getNegatedProperty:'+'prop: ', prop.to_prefix())
	propneg = prop
	#print('prop: ', prop.to_prefix())
	if DEBUG:
		print('negated prop: ', propneg.to_prefix())
	return propneg
	
def getProperties(propstr, mode): #, dtype):	
	(pp, pn1, pn2) = propstr
	print(mode, 'getProperties', len(propstr))
	prop = []
	for p in pp:
		cond1 = []
		for p1 in p:
			cond1.append(getCondition(p1))
		prop.append(cond1)

	propNeg1 = []
	for p in pn1:
		cond1 = []
		for p1 in p:
			cond1.append(getCondition(p1))
		propNeg1.append(cond1)
	
	propNeg2 = []
	for p in pn2:
		cond1 = []
		for p1 in p:
			cond1.append(getCondition(p1))
		propNeg2.append(cond1)

	if DEBUG:
		print('prop: ', prop)
		print('negated prop: ', propNeg1, propNeg2)
	
	return (prop, propNeg1, propNeg2, mode)

def getBox(params):
	edges = {}
	for par in params:
		rng = params[par]
		left = rng.leftVal()
		right = rng.rightVal()
		it = PyInterval(left, right)
		#it.mark()
		edges.update({par: it})	
		
	sbox = Box(edges)
	return sbox

def getPropertyFromData(data, fixed, outputEqns):
	fixed_eusp, fixed_obs = fixed
	print('getPropertyFromData', data, fixed_eusp, fixed_obs)
	#tsh_eu = fixed_obs[0]
	Y = data
	mode = data[0]
	tm = data[1]
	data_noise = 0.01 # DATA_NOISE
	# for key in outputEqns.keys():
	# 	data_noise.update({key:0.4}) #DATA_NOISE})
	
	time_noise = 0.08 #DATA_NOISE*0.06
	# tm_0, tm_1  = tm - 10.0, tm + 10.0 
	tm_0, tm_1  = tm*(1-time_noise), tm*(1+time_noise)
	print('tm', tm, tm_0, tm_1)
	'''prop = '((mode = {0}) & (tm > {1}) & (tm < {2}) & ('.format(mode, tm_0, tm_1)
	propn = '((mode = {0}) & (tm > {1}) & (tm < {2}) & ! ('.format(mode, tm_0, tm_1)
	st = 2 '''
	#prop = '((tm = {0}) & ('.format(tm)
	#propn = '((tm = {0}) & ! ('.format(tm)
	#prop = '((mode = {2}) & (tm > {0}) & (tm < {1}) & ('.format(tm_0, tm_1, mode)
	#propn = '((mode = {2}) & (tm > {0}) & (tm < {1}) & ! ('.format(tm_0, tm_1, mode)
	# prop = '((mode = {0}) & (tm > {1}) & (tm < {2}) & ('.format(mode, tm_0, tm_1)
	# propn = '((mode = {0}) & (tm > {1}) & (tm < {2}) & ! ('.format(mode, tm_0, tm_1)
	# propn1 = '((mode = {0}) & (tm > {1}) & (tm < {2}) & ! ('.format(mode, tm_0, tm_1)
	# propn2 = '((mode = {0}) & (tm > {1}) & (tm < {2}) & ! ('.format(mode, tm_0, tm_1)

	prop = ['(tm > {0})'.format(tm_0), '(tm < {0})'.format(tm_1)]
	propn1 = ['(tm > {0})'.format(tm_0), '(tm < {0})'.format(tm_1)]
	propn2 = [ '(tm > {0})'.format(tm_0), '(tm < {0})'.format(tm_1)]
	# prop = '((mode = {0}) & ('.format(int(mode))q_o
	# propn = '((mode = {0}) & ! ('.format(int(mode))
	st = 2
	i = st
	j = 0
	for key in outputEqns.keys():
		if i < len(data) :
			# if data[i] >= 0:
			k10, k11, k12, k13 = fixed_eusp[j], fixed_obs[j], (1-DATA_NOISE), (1+DATA_NOISE)
			# k10, k11, k12, k13 = fixed_eusp[j], fixed_obs[j], fixed_obs[j]*(1-DATA_NOISE), fixed_obs[j]*(1+DATA_NOISE)
			k21, k22, k23 = ((data[i]+data[i+1])/2, data[i]*(1-data_noise), data[i+1]*(1+data_noise))
			# k1 = min(min(max(k12, k22), k21), min(k13, k23)) #, fixed_obs[j]*(1-data_noise))
			# k2 = max(max(k12, k22), max(min(k13, k23), k21)) #, fixed_obs[j]*(1+data_noise))
			k1 = min(k10*k12, (1-data_noise)*k11) # min of eusp and euobs but not crossing TSH min
			k2 = max(k10*k13, (1+data_noise)*k11) # max of eusp and euobs but not crossing TSH max
			# k1 = max(min(k10*k12, k11*k12), k22) # min of eusp and euobs but not crossing TSH min
			# k2 = min(max(k10*k13, k11*k13), k23) # max of eusp and euobs but not crossing TSH max
			# else:				
				# k1, k2 = (data[i]*(1+data_noise), data[i+1]*(1-data_noise))
			#eqn = key #
			eqn = outputEqns[key]
			# pr = '(({0}) > {1}) & (({0}) < {2})'.format(eqn, k1, k2)

			pr = ['(({0}) > {1})'.format(eqn, k1),'(({0}) < {1})'.format(eqn, k2)]

			
			pr1 = ['(({0}) < {1})'.format(eqn, k1)]
			pr2 = ['(({0}) > {1})'.format(eqn, k2)]

			if j > 0:		
				pr1 = ['(({0}) > {1})'.format(eqn, k2)]
				pr2 = ['(({0}) < {1})'.format(eqn, k1)]

			print(key, k1, k10*k12, (1-data_noise)*k11, k2, k10*k13, (1+data_noise)*k11)

			# prop += pr if i == st else ' & '+ pr 
			# propn += pr if i == st else ' & '+ pr 
			prop += pr
			propn1 += pr1
			propn2 += pr2

			# propn1.append(pr1)
			# propn2.append(pr2)

		i+= 2
		j += 1
		if j >= 1:
			break
	# prop += '));' 
	# propn += '));' 
	return [prop], [propn1], [propn2], int(mode)

	
if __name__ == "__main__": 	
   main(sys.argv[1:])


